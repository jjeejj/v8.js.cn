<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Speeding up spread elements · V8</title><meta content="width=device-width,initial-scale=1" name=viewport><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><script>document.documentElement.className+=' js'</script><meta content="V8 v7.2 / significantly speeds up Array.from(array) as well as [...spread] for arrays, strings, sets, and maps." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog>博客</a><li><a href=/docs>文档</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Speeding up spread elements</h1><p class=meta>发布时间：<time datetime="2018-12-04 16:57:21" itemprop=datePublished title="2018-12-04 16:57:21">2018-12-04</time> · 标签： <a href=/blog/tags/ecmascript class=tag>ECMAScript</a> <a href=/blog/tags/benchmarks class=tag>benchmarks</a></header><div itemprop=articleBody><p>During his three-months internship on the V8 team, Hai Dang worked on improving the performance of <code>[...array]</code>, <code>[...string]</code>, <code>[...set]</code>, <code>[...map.keys()]</code>, and <code>[...map.values()]</code> (when the spread elements are at the start of the array literal). He even made <code>Array.from(iterable)</code> much faster as well. This article explains some of the gory details of his changes, which are included in V8 starting with v7.2.<h2 id=spread-elements>Spread elements <a href=#spread-elements class=bookmark aria-hidden=true>#</a></h2><p>Spread elements are components of array literals that have the form <code>...iterable</code>. They were introduced in ES2015 as a way to create arrays from iterable objects. For example, the array literal <code>[1, ...arr, 4, ...b]</code> creates an array whose first element is <code>1</code> followed by the elements of the array <code>arr</code>, then <code>4</code>, and finally the elements of the array <code>b</code>:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// → [1, 2, 3, 4, 5, 6, 7]</span></span></code></pre><p>As another example, any string can be spread to create an array of its characters (Unicode code points):<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'こんにちは'</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// → ['こ', 'ん', 'に', 'ち', 'は']</span></span></code></pre><p>Similarly, any set can be spread to create an array of its elements, sorted by insertion order:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'V8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'TurboFan'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// → ['V8', 'TurboFan']</span></span></code></pre><p>In general, the spread elements syntax <code>...x</code> in an array literal assumes that <code>x</code> provides an iterator (accessible through <code>x[Symbol.iterator]()</code>). This iterator is then used to obtain the elements to be inserted into the resulting array.<p>The simple use case of spreading an array <code>arr</code> into a new array, without adding any further elements before or behind, <code>[...arr]</code>, is considered a concise, idiomatic way to shallow-clone <code>arr</code> in ES2015. Unfortunately, in V8, the performance of this idiom lagged far behind its ES5 counterpart. The goal of Hai’s internship was to change that!<h2 id=why-is-(or-were!)-spread-elements-slow%3F>Why is (or were!) spread elements slow? <a href=#why-is-(or-were!)-spread-elements-slow%3F class=bookmark aria-hidden=true>#</a></h2><p>There are many ways to shallow-clone an array <code>arr</code>. For instance, you can use <code>arr.slice()</code>, or <code>arr.concat()</code>, or <code>[...arr]</code>. Or, you can write your own <code>clone</code> function that employs a standard <code>for</code>-loop:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token comment">// Pre-allocate the correct number of elements, to avoid</span></span><br><span class=highlight-line>  <span class="token comment">// having to grow the array.</span></span><br><span class=highlight-line>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span></span><br><span class=highlight-line>  <span class="token keyword">return</span> result<span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>Ideally, all these options would have similar performance characteristics. Unfortunately, if you pick <code>[...arr]</code> in V8, it is (or <em>was</em>) likely to be slower than <code>clone</code>! The reason is that V8 essentially transpiles <code>[...arr]</code> into an iteration like the following:<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">function</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token keyword">const</span> iterator <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token keyword">const</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span>next<span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>    <span class="token keyword">const</span> iteratorResult <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>iterator<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>    <span class="token keyword">if</span> <span class="token punctuation">(</span>iteratorResult<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span></span><br><span class=highlight-line>    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>iteratorResult<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class=highlight-line>  <span class="token punctuation">}</span></span><br><span class=highlight-line>  <span class="token keyword">return</span> result<span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span></code></pre><p>This code is generally slower than <code>clone</code> for a few reasons:<ol><li>It needs to create the <code>iterator</code> at the beginning by loading and evaluating the <code>Symbol.iterator</code> property.<li>It needs to create and query the <code>iteratorResult</code> object at every step.<li>It grows the <code>result</code> array at every step of the iteration by calling <code>push</code>, thus repeatedly reallocating the backing store.</ol><p>The reason for using such an implementation is that, as mentioned earlier, spreading can be done not only on arrays but, in fact, on arbitrary <em>iterable</em> objects, and must follow <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols>the iteration protocol</a>. Nevertheless, V8 should be smart enough to recognize if the object being spread is an array such that it can perform the elements extraction at a lower level and thereby:<ol><li>avoid the creation of the iterator object,<li>avoid the creation of the iterator result objects, and<li>avoid continuously growing and thus reallocating the result array (we know the number of elements in advance).</ol><p>We implemented this simple idea using <a href=/blog/csa>CSA</a> for <em>fast</em> arrays, i.e. arrays with one of the six most common <a href=/blog/elements-kinds>elements kinds</a>. The optimization applies for <a href=/blog/real-world-performance>the common real-world scenario</a> where the spread occurs at the start of the array literal, e.g. <code>[...foo]</code>. As shown in the graph below, this new fast path yields roughly a 3× performance improvement for spreading an array of length 100,000, making it about 25% faster than the hand-written <code>clone</code> loop.<figure><img alt="" src=/_img/spread-elements/spread-fast-array.png srcset="/_img/spread-elements/spread-fast-array@2x.png 2x"><figcaption>Performance improvement of spreading a fast array</figcaption></figure><p><strong>Note:</strong> While not shown here, the fast path also applies when the spread elements are followed by other components (e.g. <code>[...arr, 1, 2, 3]</code>), but not when they are preceded by others (e.g. <code>[1, 2, 3, ...arr]</code>).<h2 id=tread-carefully-down-that-fast-path>Tread carefully down that fast path <a href=#tread-carefully-down-that-fast-path class=bookmark aria-hidden=true>#</a></h2><p>That’s clearly an impressive speedup, but we must be very careful about when it is correct to take this fast path: JavaScript allows the programmer to modify the iteration behavior of objects (even arrays) in various ways. Because spread elements are specified to use the iteration protocol, we need to ensure that such modifications are respected. We do so by avoiding the fast path completely whenever the original iteration machinery has been mutated. For example, this includes situations like the following.<h3 id=own-symbol.iterator-property>Own <code>Symbol.iterator</code> property <a href=#own-symbol.iterator-property class=bookmark aria-hidden=true>#</a></h3><p>Normally, an array <code>arr</code> does not have its own <a href=https://tc39.github.io/ecma262/#sec-symbol.iterator><code>Symbol.iterator</code></a> property, so when looking up that symbol, it will be found on the array’s prototype. In the example below, the prototype is bypassed by defining the <code>Symbol.iterator</code> property directly on <code>arr</code> itself. After this modification, looking up <code>Symbol.iterator</code> on <code>arr</code> results in an empty iterator, and thus the spread of <code>arr</code> yields no elements and the array literal evaluates to an empty array.<pre class=language-js><code class=language-js><span class=highlight-line><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line>arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">return</span> <span class="token punctuation">{</span> next<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// → []</span></span></code></pre><h3 id=modified-%25arrayiteratorprototype%25>Modified <code>%ArrayIteratorPrototype%</code> <a href=#modified-%25arrayiteratorprototype%25 class=bookmark aria-hidden=true>#</a></h3><p>The <code>next</code> method can also be modified directly on <a href=https://tc39.github.io/ecma262/#sec-%25arrayiteratorprototype%25-object><code>%ArrayIteratorPrototype%</code></a>, the prototype of array iterators (which affects all arrays).<pre class=language-js><code class=language-js><span class=highlight-line>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function function-variable">next</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class=highlight-line>  <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token punctuation">}</span></span><br><span class=highlight-line><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class=highlight-line><span class="token comment">// → []</span></span></code></pre><h2 id=dealing-with-holey-arrays>Dealing with <em>holey</em> arrays <a href=#dealing-with-holey-arrays class=bookmark aria-hidden=true>#</a></h2><p>Extra care is also needed when copying arrays with holes, i.e., arrays like <code>['a', , 'c']</code> that are missing some elements. Spreading such an array, by virtue of adhering to the iteration protocol, does not preserve the holes but instead fills them with the values found in the array’s prototype at the corresponding indices. By default there are no elements in an array’s prototype, which means that any holes are filled with <code>undefined</code>. For example, <code>[...['a', , 'c']]</code> evaluates to a new array <code>['a', undefined, 'c']</code>.<p>Our fast path is smart enough to handle holes in this default situation. Instead of blindly copying the input array’s backing store, it watches out for holes and takes care of converting them to <code>undefined</code> values. The graph below contains measurements for an input array of length 100,000 containing only (tagged) 600 integers — the rest are holes. It shows that spreading such a holey array is now over 4× faster than using the <code>clone</code> function. (They used to be roughly on par, but this is not shown in the graph).<p>Note that although <code>slice</code> is included in this graph, the comparison with it is unfair because <code>slice</code> has a different semantics for holey arrays: it preserves all the holes, so it has much less work to do.<figure><img alt="" src=/_img/spread-elements/spread-holey-smi-array.png srcset="/_img/spread-elements/spread-holey-smi-array@2x.png 2x"><figcaption>Performance improvement of spreading a holey array of integers (<a href=/blog/elements-kinds><code>HOLEY_SMI_ELEMENTS</code></a>)</figcaption></figure><p>The filling of holes with <code>undefined</code> that our fast path has to perform is not as simple as it sounds: it may require converting the whole array to a different elements kind. The next graph measures such a situation. The setup is the same as above, except that this time the 600 array elements are unboxed doubles and the array has the <code>HOLEY_DOUBLE_ELEMENTS</code> elements kind. Since this elements kind cannot hold tagged values such as <code>undefined</code>, spreading involves a costly elements kind transition, which is why the score for <code>[...a]</code> is much lower than in the previous graph. Nevertheless, it is still much faster than <code>clone(a)</code>.<figure><img alt="" src=/_img/spread-elements/spread-holey-double-array.png srcset="/_img/spread-elements/spread-holey-double-array@2x.png 2x"><figcaption>Performance improvement of spreading a holey array of doubles (<a href=/blog/elements-kinds><code>HOLEY_DOUBLE_ELEMENTS</code></a>)</figcaption></figure><h2 id=spreading-strings%2C-sets%2C-and-maps>Spreading strings, sets, and maps <a href=#spreading-strings%2C-sets%2C-and-maps class=bookmark aria-hidden=true>#</a></h2><p>The idea of skipping the iterator object and avoiding growing the result array equally applies to spreading other standard data types. Indeed, we implemented similar fast paths for primitive strings, for sets, and for maps, each time taking care to bypass them in the presence of modified iteration behavior.<p>Concerning sets, the fast path supports not only spreading a set directly ([...set]), but also spreading its keys iterator (<code>[...set.keys()]</code>) and its values iterator (<code>[...set.values()]</code>). In our micro-benchmarks, these operations are now about 18× faster than before.<p>The fast path for maps is similar but does not support spreading a map directly (<code>[...map]</code>), because we consider this an uncommon operation. For the same reason, neither fast path supports the <code>entries()</code> iterator. In our micro-benchmarks, these operations are now about 14× faster than before.<p>For spreading strings (<code>[...string]</code>), we measured a roughly 5× improvement, as shown in the graph below by the purple and green lines. Note that this is even faster than a TurboFan-optimized for-of-loop (TurboFan understands string iteration and can generate optimized code for it), represented by the blue and pink lines. The reason for having two plots in each case is that the micro-benchmarks operate on two different string representations (one-byte strings and two-byte strings).<figure><img alt="" src=/_img/spread-elements/spread-string.png srcset="/_img/spread-elements/spread-string@2x.png 2x"><figcaption>Performance improvement of spreading a string</figcaption></figure><figure><img alt="" src=/_img/spread-elements/spread-set.png srcset="/_img/spread-elements/spread-set@2x.png 2x"><figcaption>Performance improvement of spreading a set with 100,000 integers (magenta, about 18×), shown here in comparison with a <code>for</code>-<code>of</code> loop (red)</figcaption></figure><h2 id=improving-array.from-performance>Improving <code>Array.from</code> performance <a href=#improving-array.from-performance class=bookmark aria-hidden=true>#</a></h2><p>Fortunately, our fast paths for spread elements can be reused for <code>Array.from</code> in the case where <code>Array.from</code> is called with an iterable object and without a mapping function, for example, <code>Array.from([1, 2, 3])</code>. The reuse is possible because in this case, the behavior of <code>Array.from</code> is exactly the same as that of spreading. It results in an enormous performance improvement, shown below for an array with 100 doubles.<figure><img alt="" src=/_img/spread-elements/array-from-array-of-doubles.png srcset="/_img/spread-elements/array-from-array-of-doubles@2x.png 2x"><figcaption>Performance improvement of <code>Array.from(array)</code> where <code>array</code> contains 100 doubles</figcaption></figure><h2 id=conclusion>Conclusion <a href=#conclusion class=bookmark aria-hidden=true>#</a></h2><p>V8 v7.2 / Chrome 72 greatly improves the performance of spread elements when they occur at the front of the array literal, for example <code>[...x]</code> or <code>[...x, 1, 2]</code>. The improvement applies to spreading arrays, primitive strings, sets, maps keys, maps values, and — by extension — to <code>Array.from(x)</code>.</div><footer><div><p>作者：Hai Dang & Georg Neis.</div><a href=https://twitter.com/v8js/status/1070344545685118976 class=retweet>Retweet this article!</a></footer><footer><div><img alt="" src=/_img/avatars/justjavac.jpg srcset="/_img/avatars/justjavac@2x.jpg 2x" height=96 lazyload=on width=96><p>译者：迷渡 (<a href=https://github.com/justjavac>@justjavac</a>)，<a href=http://V8.js.cn>V8.js.cn</a> 站长.</div></footer></article></main><footer id=footer><nav><a href=https://v8.dev/blog/spread-elements>原文</a> · <a href=/logo>商标</a> · <a href=/terms>条款</a> · <a href=https://policies.google.com/privacy>隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/spread-elements.md rel=nofollow>在 GitHub 编辑此页面</a></nav><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>